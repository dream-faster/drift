from typing import Callable, List, Optional, Union

import pandas as pd
from sklearn.base import BaseEstimator

from ..all_types import TransformationsOverTime
from ..models.base import Model
from ..splitters import Split, Splitter
from ..transformations.base import Composite, Transformation, Transformations
from ..utils.list import wrap_in_list
from .backend.ray import process_transformations as process_transformations_ray
from .backend.sequential import (
    process_transformations as process_transformations_sequential,
)
from .common import deepcopy_transformations, recursively_fit_transform
from .convenience import replace_transformation_if_not_drift_native
from .types import Backend, TrainMethod


def train(
    transformations: List[
        Union[Transformation, Composite, Model, Callable, BaseEstimator]
    ],
    X: pd.DataFrame,
    y: pd.Series,
    splitter: Splitter,
    sample_weights: Optional[pd.Series] = None,
    train_method: TrainMethod = TrainMethod.parallel,
    backend: Backend = Backend.no,
) -> TransformationsOverTime:
    """
    Train a list of transformations over time.
    """

    transformations = wrap_in_list(transformations)
    transformations: Transformations = replace_transformation_if_not_drift_native(
        transformations
    )

    splits = splitter.splits(length=len(y))
    if len(splits) == 0:
        raise ValueError("No splits were generated by the Splitter.")

    if train_method == TrainMethod.parallel:
        process_function = process_transformations_sequential
        if backend == Backend.ray:
            process_function = process_transformations_ray
        processed = process_function(
            process_transformations_window,
            transformations,
            X,
            y,
            sample_weights,
            splits,
        )
        processed_idx, processed_transformations = zip(*processed)
    elif train_method == TrainMethod.sequential:
        only_transformations = [
            process_transformations_window(
                X,
                y,
                sample_weights,
                transformations,
                split,
            )
            for split in splits
        ]
        idx = [split.model_index for split in splits]

    return [
        pd.Series(
            transformation_over_time,
            index=processed_idx,
            name=transformation_over_time[0].name,
        )
        for transformation_over_time in zip(*processed_transformations)
    ]


def process_transformations_window(
    X: pd.DataFrame,
    y: pd.Series,
    sample_weights: Optional[pd.Series],
    transformations: List[Union[Transformation, Composite]],
    split: Split,
) -> Tuple[int, List[Union[Transformation, Composite]]]:

    X_train = X.iloc[split.train_window_start : split.train_window_end]
    y_train = y.iloc[split.train_window_start : split.train_window_end]

    sample_weights_train = (
        sample_weights.iloc[split.train_window_start : split.train_window_end]
        if sample_weights is not None
        else None
    )

    transformations = deepcopy_transformations(transformations)
    X_train = recursively_fit_transform(
        X_train, y_train, sample_weights_train, transformations
    )

    return split.model_index, transformations
